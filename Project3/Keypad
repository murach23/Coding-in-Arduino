#include <avr/io.h>
#include <avr/interrupt.h>
#define PRELOAD 0xFE0B // = 65536 - 500 decimal gives is 500 interrupts per second

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
char result;
// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET    -1 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define MPU_addr 0x68  // I2C address of the MPU-6050

#define Row0 2
#define Row1 4
#define Row2 5
#define Row3 6

#define Column0 7
#define Column1 10
#define Column2 A2
#define trimPot A3

// Define number of steps per revolution
// Our stepper has 20 steps per revolution
// This is equivalent to
// 18 degrees of a turn per step
#define stepsPerRevolution 20
float revPsec = 0.0;
// Give the motor control pins names:
#define pwmA 3
#define pwmB 11
#define breakA 9
#define breakB 8
#define dirA 12
#define dirB 13
#define sen0 A0
#define sen1 A1

// ---------------------------------------------------------
//                    MODULE 5 Variables
// ---------------------------------------------------------
// module5 is the login and scheduller
// module5 variables
bool init_module5_clock;
// ---------------------------------------------------------
//                    MODULE 6 Variables
// ---------------------------------------------------------
// module6 is the trimpot reader
// module6 variables
bool init_module6_clock;


// ---------------------------------------------------------
//                    MODULE 7 Variables
// ---------------------------------------------------------
// module7 is the motor monitor
// module7 variables
bool init_module7_clock;
// ---------------------------------------------------------
//                    MODULE 8 Variables
// ---------------------------------------------------------
// module8 is the accelerometer driver
// module8 variables
bool init_module8_clock;

// definition for the type of the button states
enum button_t { notPRESSED, partialPRESS, normalPRESS, heldPRESS, stuck};
button_t keyStatus[12] = {notPRESSED};
button_t oldStatus[12] = {notPRESSED};
// ---------------------------------------------------------
//                    MODULE 9 Variables
// ---------------------------------------------------------
// module9 is the Keypad driver
// module9 variables
bool init_module9_clock;

// ---------------------------------------------------------
//                    MODULE 10 Variables
// ---------------------------------------------------------
// module10 is the Key display driver
// module10 variables
bool init_module10_clock;

void testRow(char r) {
  switch (r) {
    case 0: {
        digitalWrite(Row0, 0);
        pinMode(Row0, OUTPUT);
        pinMode(Row1, INPUT_PULLUP);
        pinMode(Row2, INPUT_PULLUP);
        pinMode(Row3, INPUT_PULLUP);
        break;
      }
    case 1: {
        pinMode(Row0, INPUT_PULLUP);
        digitalWrite(Row1, 0);
        pinMode(Row1, OUTPUT);
        pinMode(Row2, INPUT_PULLUP);
        pinMode(Row3, INPUT_PULLUP);
        break;
      }
    case 2: {
        pinMode(Row0, INPUT_PULLUP);
        pinMode(Row1, INPUT_PULLUP);
        digitalWrite(Row2, 0);
        pinMode(Row2, OUTPUT);
        pinMode(Row3, INPUT_PULLUP);
        break;
      }
    case 3: {
        pinMode(Row0, INPUT_PULLUP);
        pinMode(Row1, INPUT_PULLUP);
        pinMode(Row2, INPUT_PULLUP);
        digitalWrite(Row3, 0);
        pinMode(Row3, OUTPUT);
        break;
      }
    default: {
        pinMode(Row0, INPUT_PULLUP);
        pinMode(Row1, INPUT_PULLUP);
        pinMode(Row2, INPUT_PULLUP);
        pinMode(Row3, INPUT_PULLUP);
        break;
      }
  }
}

bool testColumn(char c) {
  return (
           (c < 0) ? true : (
             (c == 0) ? digitalRead(Column0) : (
               (c == 1) ? digitalRead(Column1) : (
                 (c == 2) ? digitalRead(Column2) : true
               )
             )
           )
         );
}

void setup() {
  // make sure this comes first in your code to avoid shorts
  pinMode(Column0, INPUT_PULLUP);
  pinMode(Column1, INPUT_PULLUP);
  pinMode(Column2, INPUT_PULLUP);

  pinMode(Row0, INPUT_PULLUP);
  pinMode(Row1, INPUT_PULLUP);
  pinMode(Row2, INPUT_PULLUP);
  pinMode(Row3, INPUT_PULLUP);
  testRow(-1); // do not test a row

  // Set the PWM and brake pins so that the direction pins can be used to control the motor:
  pinMode(dirA, OUTPUT);
  pinMode(dirB, OUTPUT);

  pinMode(pwmA, OUTPUT);
  pinMode(pwmB, OUTPUT);
  pinMode(breakA, OUTPUT);
  pinMode(breakB, OUTPUT);

  digitalWrite(pwmA, HIGH);
  digitalWrite(pwmB, HIGH);
  digitalWrite(breakA, LOW);
  digitalWrite(breakB, LOW);

  Serial.begin(9600);
  Wire.begin();
  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address may also be 0x3D for 128x64
    Serial.println(F("SSD1306 allocation failed")); // has the video buffer got enough RAM?
    for (;;); // Don't proceed, loop forever
  }
  display.setTextWrap(false); // do not wrap the text
  display.setTextSize(1);     // Normal 1:1 pixel scale
  display.clearDisplay();
  // Show the display buffer on the screen. You MUST call display() after
  // drawing commands to make them visible on screen!
  display.display();

  // initialize Timer1
  cli();         // disable global interrupts
  TCCR1A = 0;    // set entire TCCR1A register to 0
  TCCR1B = 0;    // set entire TCCR1B register to 0
  // (as we do not know the initial  values)

  // enable Timer1 overflow interrupt:
  TIMSK1 |= (1 << TOIE1); //Atmega8 has no TIMSK1 but a TIMSK register
  // Preload
  TCNT1 = PRELOAD;
  TCCR1B |= (1 << CS11); // Sets bit CS11 in TCCR1B
  TCCR1B |= (1 << CS10); // and CS10
  //the clock source is divided by 64, i.e. one clock cycle every 64 / (16 * 10^6) = 4 * 10^(-6) = 0.000004s

  // This is achieved by shifting binary 1 (0b00000001)
  // to the left by CS11 or CS10 bits. This is then bitwise
  // OR-ed into the current value of TCCR1B, which effectively set
  // this one bit high.
  // enable global interrupts:
  sei();

  // initialise all modules in the system
  // snip
  // in other words, set all init_module_clock variables to true here
  init_module10_clock = true;
  init_module6_clock = true;
  init_module7_clock = true;
  init_module9_clock = true;
  init_module5_clock = true;
  Wire.beginTransmission(MPU_addr);
  Wire.write(0x6B);  // PWR_MGMT_1 register
  Wire.write(0);     // set to zero (wakes up the MPU-6050)
  Wire.endTransmission(true);
}

// here is the ISR executed by the CPU when the corresponding interrupt occurs
ISR(TIMER1_OVF_vect)
{
  TCNT1 = PRELOAD; // reload the timer preload

  //////////////////////////////////////////////////////////
  // motor module
  //////////////////////////////////////////////////////////
  {
    static unsigned long m;
    static unsigned char thisStep = 0;

    if (((long)(micros() - m)) > (1000000L / (stepsPerRevolution * abs(revPsec)))) {
      // you can control the speed and direction by assigning the revPsec variable
      m = micros();

      switch (thisStep) {
        case 0:  // 01
          digitalWrite(dirA, LOW);
          digitalWrite(dirB, HIGH);
          if (revPsec > 0) thisStep++;
          else if (revPsec < 0) thisStep = 3; //direction
          break;
        case 1:  // 11
          digitalWrite(dirA, HIGH);
          digitalWrite(dirB, HIGH);
          if (revPsec > 0) thisStep++;
          else if (revPsec < 0) thisStep--; //direction
          break;
        case 2:  // 10
          digitalWrite(dirA, HIGH);
          digitalWrite(dirB, LOW);
          if (revPsec > 0) thisStep++;
          else if (revPsec < 0)  thisStep--; //direction
          break;
        case 3:  // 00
          digitalWrite(dirA, LOW);
          digitalWrite(dirB, LOW);
          if (revPsec > 0) thisStep = 0;
          else if (revPsec < 0) thisStep--; //direction
          break;
        default: thisStep = 0;
      }
    }
  }
}

/*
   Top left is position 0,0
   bottom right is position 20, 7
   There are 8 lines of text at text size 1
   There are 21 columns of text at size 1
   These need to be scaled for different text sizes
*/
void oled(unsigned char x, unsigned char y, const __FlashStringHelper *s) {
  byte *s1 = (byte *)s;
  display.setCursor(x * 6, y * 8);                    // start co-ordinates
  for (byte i = 0; s1[i] != 0; i++) display.print(F(" ")); // make space for the new text
  display.setTextColor(SSD1306_WHITE, SSD1306_BLACK); // white color for the new text
  display.setCursor(x * 6, y * 8);                    // start co-ordinates
  display.print(s);                                   // write the new text
  display.display();                                  // show it
}

// returns the number on the key
char n(unsigned char kI) {
  if (kI >= 11) return (-1);
  else if (kI == 10) return (0);
  else return ((kI + 1) % 10);
}

void loop()
{
  
  { // module 5    module5 is the login and scheduller
#define password 159
    static unsigned long module_time, module_delay, userToken, stan;
    static bool module_doStep;
    static char module_state = 0; // state variable for module 6
    static unsigned char keyIndex, state;

    if (init_module5_clock) {
      module_delay = 5;
      module_time = millis();
      module_doStep = false;
      init_module5_clock = false;
      module_state = 0;
    }
    else {
      unsigned long m;
      m = millis();
      if (((long)(m - module_time)) > module_delay) { // can you make this roll-over safe?
        module_time = m; module_doStep = true;
      }
      else module_doStep = false;
    }
    {
      //  static char old;
      //  if (old!=module_state) {
      //    Serial.print("state = "); Serial.println(old=module_state, DEC); Serial.println(userToken);

    }
    if (module_doStep) {
      switch (module_state) {
        case -1: {
            // stop motor, apply the brakes
            digitalWrite(pwmA, HIGH);
            digitalWrite(pwmB, HIGH);
            digitalWrite(breakA, HIGH);
            digitalWrite(breakB, HIGH);
            // stop trimpot and motor monitor modules
            init_module6_clock = true;
            init_module10_clock = true;
            // stop accel and key displayer modules
            init_module8_clock = true;
            init_module7_clock = true;
            // stop the motor, zero the velocity of the motor
            revPsec = 0.0;
            // display "Invalid input." on the oled
            display.clearDisplay();
            oled(3, 1, F("Invalid input. Login password"));
            module_state = 0;
          }
        case 0: {

            // stop motor, apply the brakes
            digitalWrite(pwmA, HIGH);
            digitalWrite(pwmB, HIGH);
            digitalWrite(breakA, HIGH);
            digitalWrite(breakB, HIGH);
            // stop trimpot and motor monitor modules
            init_module6_clock = true;
            init_module10_clock = true;
            // stop accel and key displayer modules
            init_module8_clock = true;
            init_module7_clock = true;
            // stop the motor, zero the velocity of the motor
            revPsec = 0.0;
            // display "Login password:" on the oled

            // userToken is zeroed
            if (stan == 0) {
              display.clearDisplay();
              oled(0, 1, F("Login password"));
            }
            userToken = 0;
            stan = 0;
            module_state = 1;
            break;

          }
        case 1: {

            // stop motor, apply the brakes
            digitalWrite(pwmA, HIGH);
            digitalWrite(pwmB, HIGH);
            digitalWrite(breakA, HIGH);
            digitalWrite(breakB, HIGH);
            // stop trimpot and motor monitor modules
            init_module6_clock = true;
            init_module10_clock = true;
            // stop accel and key displayer modules
            init_module8_clock = true;
            init_module7_clock = true;
            // stop the motor, zero the velocity of the motor   keyStatus[]={notPRESSED}
            revPsec = 0.0;
            // check the keyStatus for pressed keys, check key index for keys********
            for (int i = 0; i <= 11; i++) {

              if (oldStatus[i] == keyStatus[i]) {
                if (keyStatus [i] == normalPRESS) keyIndex = 11;
              }
              else if (oldStatus[i] != keyStatus[i]) {
                oldStatus[i] = keyStatus[i];
                if (keyStatus[i] == normalPRESS) {
                  module_state = 2;
                  keyIndex = i;

                }
                else module_state = 1;
              }
            }


            // if no key is normally pressed, stay in this state
            // else move to case 2
            break;

          }
        case 2: {
            // stop motor, apply the brakes
            digitalWrite(pwmA, HIGH);
            digitalWrite(pwmB, HIGH);
            digitalWrite(breakA, HIGH);
            digitalWrite(breakB, HIGH);
            // stop trimpot and motor monitor modules
            init_module6_clock = true;
            init_module10_clock = true;
            // stop accel and key displayer modules
            init_module8_clock = true;
            init_module7_clock = true;

            // stop the motor, zero the velocity of the motor
            revPsec = 0.0;
            // is # pressed? if so, check userToken == password and go to the open state 3
            if (keyStatus[11] == normalPRESS) {
              if (userToken == password) {
                module_state = 3;
              }
              else {
                module_state = -1;
                stan = 1;
              }
            }



            // else module_state = -1;// else go to the error state -1
            // check for validity of the input, i.e. ignore * button, etc

            // if all's well userToken = userToken*10+n(keyIndex) and go back to state 1
            else {
              if (keyIndex == 9 | keyIndex == 11) module_state = 1;
              else {
                userToken = userToken * 10 + n(keyIndex);
                module_state = 1;
              }
            }

            // else module_state = -1;
            break;
          }
        case 3: {
            display.clearDisplay();
            digitalWrite(breakA, LOW);
            digitalWrite(breakB, LOW);
            // this is the open state
            // release all modules and let them run
            init_module6_clock = false;
            init_module10_clock = false;
            init_module8_clock = false;
            init_module7_clock = false;
            // draw the key grid on the oled. you may use |, -, + and space too
            display.drawLine(15, 0, 15, display.height(), SSD1306_WHITE);
            display.drawLine(30, 0, 30, display.height(), SSD1306_WHITE);
            display.drawLine(0, 15, 45, 15, WHITE );
            display.drawLine(0, 30, 45, 30, WHITE );
            display.drawLine(0, 45, 45, 45, WHITE );
            // release the breaks
            // move to state 4
            module_state = 4;
            break;

          }
        case 4: {
            // this is the open state
            // release all modules and let them run
            init_module6_clock = false;
            init_module10_clock = false;
            init_module8_clock = false;
            init_module7_clock = false;
            digitalWrite(breakA, LOW);
            digitalWrite(breakB, LOW);
            // draw the key grid on the oled. you may use |, -, + and space too
            //              display.drawLine(15, 0, 15, display.height(), SSD1306_WHITE);
            //              display.drawLine(30, 0, 30, display.height(), SSD1306_WHITE);
            //              display.drawLine(0, 15, 45, 15, WHITE );
            //              display.drawLine(0, 30, 45, 30, WHITE );
            //              display.drawLine(0, 45, 45, 45, WHITE );
            if (keyStatus[9] == heldPRESS & keyStatus[11] == heldPRESS)
            {
              module_state = 0;
              stan = 0;
            }
            else if ((keyStatus[9] == stuck | keyStatus[11] == stuck) & (keyStatus[0] == normalPRESS & keyStatus[4] == normalPRESS & keyStatus[8] == normalPRESS ))
            {
              stan = 0;
              module_state = 0;
            }
            break;

            // wait for *h+#h event, if so shut down and go to state 0
          }
        default: module_state = 0;
      }
    }
  }



  { // module 6  // module6 is the trimpot reader
    static unsigned long module_time, module_delay;
    static bool module_doStep;
    static unsigned char module_state = 0; // state variable for module 6
    static unsigned char thisStep = 0;
    static byte x, y;
    int potVal, old;

    if (init_module6_clock) {
      module_delay = 300;
      module_time = millis();
      module_doStep = false;
      init_module6_clock = false;
      module_state = 0;
    }
    else {
      unsigned long m;
      m = millis();
      if (((long)(m - module_time)) > module_delay) { // can you make this roll-over safe?
        module_time = m; module_doStep = true;
      }
      else module_doStep = false;
    }

    if (module_doStep) {
      //analogRead(trimPot) and calculate the revPsec variable for the revolutions per second
      // add a bit of hysteresis to the reading of the trimPot and check on the sensor pins
      // sen0 and sen1 to see if the motor is ok

      //switch (module_state)
      {
        potVal = analogRead(trimPot);
        if (abs(old - potVal) > 5) {
          old = potVal;
        }
        x = potVal;
        y = revPsec;
        revPsec = 16.0 / 1023.0 * potVal - 8;
        potVal = analogRead(trimPot);
        if ( potVal > 514 ) {
          // revPsec = 0.0;
          revPsec++;
        }
        else if (potVal < 514 ) {
          //revPsec = 0.0;
          revPsec--;
        }



      }

    }

  }


  { // module 7 // module7 is the motor monitor
    static unsigned long module_time, module_delay;
    static bool module_doStep;
    static unsigned char module_state = 0; // state variable for module 7
    static byte s0 = 1, s1 = 1;


    if (init_module7_clock) {
      module_delay = 20;
      module_time = millis();
      module_doStep = false;
      init_module7_clock = false;
      module_state = 0;
    }
    else {
      unsigned long m;
      m = millis();
      if (((long)(m - module_time)) > module_delay) { // can you make this roll-over safe?
        module_time = m; module_doStep = true;
      }
      else module_doStep = false;
    }

    if (module_doStep) {
      s0 = analogRead(sen0);
      s1 = analogRead(sen1);

      if ( s0 < 1 & s1 < 1) {

        init_module6_clock = true;
        revPsec = 0.0;
        display.setCursor(75, 31);
        display.print(revPsec);
        oled(18, 4, F("rps"));
        oled(13, 6, F("off"));
        digitalWrite(breakA, HIGH);
        digitalWrite(breakB, HIGH);
      }
      else if (s0 > 1 || s1 > 1) {
        oled(13, 6, F("ok "));
        display.setCursor(75, 31);
        display.print(revPsec);
        oled(18, 4, F("rps"));
      }
      // analogRead(sen0) and analogRead(sen1) to see if the motor is ok
      // if the motor is off stop the trimpot module and assign 0.0 to the revPsec to stop the motor
      // else show "motor ok" and the revPsec on the oled
    }
  }

  { // module 8 // module8 is the accelerometer driver
    static unsigned long module_time, module_delay;
    static bool module_doStep;
    static unsigned char module_state = 0; // state variable for module 10
    int AcZ, AcX, AcY, TEMP_OUT, T;

    if (init_module8_clock) {
      module_delay = 100;
      module_time = millis();
      module_doStep = false;
      init_module8_clock = false;
      module_state = 0;
    }
    else {
      unsigned long m;
      m = millis();
      if (((long)(m - module_time)) > module_delay) { // can you make this roll-over safe?
        module_time = m; module_doStep = true;
      }
      else module_doStep = false;
    }

    if (module_doStep) {
      // Put the MPU6050 IC into the correct operating mode
      Wire.beginTransmission(MPU_addr);
      Wire.write(0x3B);  // starting with register 0x3B (ACCEL_XOUT_H)
      Wire.endTransmission(false);
      Wire.requestFrom(MPU_addr, 6, true); // request a total of 6 registers
      AcX = Wire.read() << 8 | Wire.read(); // 0x3B (ACCEL_XOUT_H) & 0x3C (ACCEL_XOUT_L)
      AcY = Wire.read() << 8 | Wire.read(); // 0x3D (ACCEL_YOUT_H) & 0x3E (ACCEL_YOUT_L)
      AcZ = Wire.read() << 8 | Wire.read(); // 0x3F (ACCEL_ZOUT_H) & 0x40 (ACCEL_ZOUT_L)
      Wire.beginTransmission(MPU_addr);
      Wire.write(0x41);
      // starting with register 0x3B (ACCEL_XOUT_H)
      Wire.endTransmission(false);
      Wire.requestFrom(MPU_addr, 2, true); // request a total of 6 registers
      TEMP_OUT = Wire.read() << 8 | Wire.read(); // 0x3B (ACCEL_XOUT_H) & 0x3C (ACCEL_XOUT_L)

      (T = (TEMP_OUT / 340.00) + 36.53);

      display.setTextSize(1);
      display.setCursor(78, 16);
      display.print(T);
      oled(15, 2, F("C"));
      display.setCursor(98 , 16);
      display.print((char)247);
      display.display();

      if (AcZ > 900 & AcX < -14000) oled(13, 0, F("b"));
      if (AcZ >  14000 ) oled(13, 0, F("F"));
      if (AcX <  -3000 & AcZ < -4000)  oled(13, 0, F("U"));
      if (AcX >  14000) oled(13, 0, F("L"));
      if (AcY >  14000) oled(13, 0, F("r"));
      if (AcY < -14000) oled(13, 0, F("l"));
    }
  }


  { //module 9 // module9 is the Keypad driver
    static unsigned long module_time, module_delay;
    static bool module_doStep;
    static unsigned long module_keypadDebounceTime[12];
    static unsigned char state1 = 0, state2 = 0, state3 = 0, state4 = 0, state5 = 0, state6 = 0, state7 = 0, state8 = 0, state9 = 0,  stateS = 0, state0 = 0, stateH = 0; // state variable for module 9
    static unsigned char module_i;
    if (init_module9_clock) {
      module_delay = 10;
      module_time = millis();
      module_doStep = false;
      init_module9_clock = false;
      //state1=0, state2=0, state3=0, state4=0, state5=0, state6=0, state7=0, state8=0, state9=0,  stateS=0, state0=0, stateH=0;

    }
    else {
      unsigned long m;
      m = millis();
      if (((long)(m - module_time)) > module_delay) { // can you make this roll-over safe?
        module_time = m; module_doStep = true;
      }
      else module_doStep = false;
    }

    if (module_doStep) {
      // this is my keypad module. it has 12 FSMs running it it as threads
      // chacking on the keys and updating the keyStatus[] array
      // this can be done in 4 modules of 3 threads each, i.e.
      // one module per row which will improve performance


      switch (state1) {

        case 0: {
            testRow(0);
            // Is column 0 Low?
            if (!testColumn(0)) { // 11111111111111111 detected
              module_keypadDebounceTime[0] = millis();
              state1 = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[0])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[0] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[0] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[0] = heldPRESS);
            else                           (keyStatus[0] = stuck);
            // Pull row 0 Low
            testRow(0);

            // Read the column value
            if (testColumn(0)) {
              keyStatus[0] = notPRESSED;
              state1 = 0;
            }
            else state1 = 1;
            break;
          }
        default: state1 = 0;
      }



      switch (state2) {
        case 0: {
            testRow(0);
            // Is column 0 Low?
            if (!testColumn(1)) { // 2 detected
              module_keypadDebounceTime[1] = millis();
              state2 = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[1])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[1] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[1] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[1] = heldPRESS);
            else                           (keyStatus[1] = stuck);
            // Pull row 0 Low
            testRow(0);

            // Read the column value
            if (testColumn(1)) {
              keyStatus[1] = notPRESSED;
              state2 = 0;
            }
            else state2 = 1;
            break;
          }
        default: state2 = 0;
      }


      switch (state3) {
        case 0: {
            testRow(0);
            // Is column 0 Low?
            if (!testColumn(2)) { // 3 detected
              module_keypadDebounceTime[2] = millis();
              state3 = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[2])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[2] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[2] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[2] = heldPRESS);
            else                           (keyStatus[2] = stuck);
            // Pull row 0 Low
            testRow(0);

            // Read the column value
            if (testColumn(2)) {
              keyStatus[2] = notPRESSED;
              state3 = 0;
            }
            else state3 = 1;
            break;
          }
        default: state3 = 0;
      }





      switch (state4) {
        case 0: {
            testRow(1);
            // Is column 0 Low?
            if (!testColumn(0)) { // 4 detected
              module_keypadDebounceTime[3] = millis();
              state4 = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[3])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[3] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[3] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[3] = heldPRESS);
            else                           (keyStatus[3] = stuck);
            // Pull row 0 Low
            testRow(1);

            // Read the column value
            if (testColumn(0)) {
              keyStatus[3] = notPRESSED;
              state4 = 0;
            }
            else state4 = 1;
            break;
          }
        default: state4 = 0;
      }



      switch (state5) {
        case 0: {
            testRow(1);
            // Is column 0 Low?
            if (!testColumn(1)) { // 5 detected
              module_keypadDebounceTime[4] = millis();
              state5 = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[4])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[4] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[4] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[4] = heldPRESS);
            else                           (keyStatus[4] = stuck);
            // Pull row 0 Low
            testRow(1);

            // Read the column value
            if (testColumn(1)) {
              keyStatus[4] = notPRESSED;
              state5 = 0;
            }
            else state5 = 1;
            break;
          }
        default: state5 = 0;
      }



      switch (state6) {
        case 0: {
            testRow(1);
            // Is column 0 Low?
            if (!testColumn(2)) { // 6 detected
              module_keypadDebounceTime[5] = millis();
              state6 = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[5])); // make this roll-over safe
            //display.clearDisplay();
            if (m < 300)                   (keyStatus[5] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[5] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[5] = heldPRESS);
            else                           (keyStatus[5] = stuck);
            // Pull row 0 Low
            testRow(1);

            // Read the column value
            if (testColumn(2)) {
              keyStatus[5] = notPRESSED;
              state6 = 0;
            }
            else state6 = 1;
            break;
          }
        default: state6 = 0;
      }





      // snip
      switch (state7) {
        case 0: {
            testRow(2);
            // Is column 0 Low?
            if (!testColumn(0)) { // 7 detected
              module_keypadDebounceTime[6] = millis();
              state7 = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[6])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[6] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[6] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[6] = heldPRESS);
            else                           (keyStatus[6] = stuck);
            // Pull row 0 Low
            testRow(2);

            // Read the column value
            if (testColumn(0)) {
              keyStatus[6] = notPRESSED;
              state7 = 0;
            }
            else state7 = 1;
            break;
          }
        default: state7 = 0;
      }



      switch (state8) {
        case 0: {
            testRow(2);
            // Is column 0 Low?
            if (!testColumn(1)) { // 8 detected
              module_keypadDebounceTime[7] = millis();
              state8 = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[7])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[7] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[7] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[7] = heldPRESS);
            else                           (keyStatus[7] = stuck);
            // Pull row 0 Low
            testRow(2);

            // Read the column value
            if (testColumn(1)) {
              keyStatus[7] = notPRESSED;
              state8 = 0;
            }
            else state8 = 1;
            break;
          }
        default: state8 = 0;
      }


      switch (state9) {
        case 0: {
            testRow(2);
            // Is column 0 Low?
            if (!testColumn(2)) { // 9 detected
              module_keypadDebounceTime[8] = millis();
              state9 = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[8])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[8] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[8] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[8] = heldPRESS);
            else                           (keyStatus[8] = stuck);
            // Pull row 0 Low
            testRow(2);

            // Read the column value
            if (testColumn(2)) {
              keyStatus[8] = notPRESSED;
              state9 = 0;
            }
            else state9 = 1;
            break;
          }
        default: state9 = 0;
      }






      switch (stateS) {
        case 0: {
            testRow(3);
            // Is column 0 Low?
            if (!testColumn(0)) { // * detected
              module_keypadDebounceTime[9] = millis();
              stateS = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[9])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[9] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1500) (keyStatus[9] = normalPRESS);
            else if (1500 <= m && m < 5000)(keyStatus[9] = heldPRESS);
            else                           (keyStatus[9] = stuck);
            // Pull row 0 Low
            testRow(3);

            // Read the column value
            if (testColumn(0)) {
              keyStatus[9] = notPRESSED;
              stateS = 0;
            }
            else stateS = 1;
            break;
          }
        default: stateS = 0;
      }



      switch (state0) {

        case 0: {
            testRow(3);
            // Is column 0 Low?
            if (!testColumn(1)) { // 0 detected
              module_keypadDebounceTime[10] = millis();
              state0 = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[10])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[10] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[10] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[10] = heldPRESS);
            else                           (keyStatus[10] = stuck);
            // Pull row 0 Low
            testRow(3);

            // Read the column value
            if (testColumn(1)) {
              keyStatus[10] = notPRESSED;
              state0 = 0;
            }
            else state0 = 1;
            break;
          }
        default: state0 = 0;
      }



      switch (stateH) {
        case 0: {
            testRow(3);
            // Is column 0 Low?
            if (!testColumn(2)) { // # detected
              module_keypadDebounceTime[11] = millis();
              stateH = 1;
            } testRow(-1);
            break;
          }
        case 1: {
            unsigned long m = ((long)(millis() - module_keypadDebounceTime[11])); // make this roll-over safe
            // display.clearDisplay();
            if (m < 300)                   (keyStatus[11] = partialPRESS); // just to show different positions
            else if (300 <= m && m < 1000) (keyStatus[11] = normalPRESS);
            else if (1000 <= m && m < 5000)(keyStatus[11] = heldPRESS);
            else                           (keyStatus[11] = stuck);
            // Pull row 0 Low
            testRow(3);

            // Read the column value
            if (testColumn(2)) {
              keyStatus[11] = notPRESSED;
              stateH = 0;
            }
            else stateH = 1;
            break;
          }
        default: stateH = 0;
      }
    }



    // nothing detected

    //testRow(-1);
    // oled(0,8,F("No key pressed"));  // just to show different positions




  }


  { // module 10 // module10 is the Key display driver
    static unsigned long module_time, module_delay;
    static bool module_doStep;

    static unsigned char state1 = 0, state2 = 0, state3 = 0, state4 = 0, state5 = 0, state6 = 0, state7 = 0, state8 = 0, state9 = 0,  stateS = 0, state0 = 0, stateH = 0; // state variable for module 9
    static unsigned char module_i;
    if (init_module10_clock) {
      module_delay = 101;
      module_time = millis();
      module_doStep = false;
      init_module10_clock = false;
      //state1 = state2 = state3 = state4 = 0;
    }
    else {
      unsigned long m;
      m = millis();
      if (((long)(m - module_time)) > module_delay) { // can you make this roll-over safe?
        module_time = m; module_doStep = true;
      }
      else module_doStep = false;
    }

    if (module_doStep) {
      // this is my keypad module. it has 12 FSMs running it it as threads
      // chacking on the keys and updating the keyStatus[] array
      // this can be done in 4 modules of 3 threads each, i.e.
      // one module per row which will improve performance
      switch (state1) {

        case 0: {

            if (keyStatus[0] != notPRESSED) {
              state1 = 1;
            }
            break;
          }
        case 1: {
            if      (keyStatus[0] == partialPRESS)oled(0, 0, F("1p")); // just to show different positions
            else if (keyStatus[0] == normalPRESS)oled(0, 0, F("1n"));
            else if (keyStatus[0] == heldPRESS)oled(0, 0, F("1h"));
            else if  (keyStatus[0] == stuck)oled(0, 0, F("1s"));
            else oled(0, 0, F("  "));
            if (keyStatus[0] == notPRESSED) {
              state1 = 0;
            }
            else state1 = 1;
            break;
          }
        default: state1 = 0;
      }

      switch (state2) {

        case 0: {

            if (keyStatus[1] != notPRESSED) {
              state2 = 1;
            }
            break;
          }
        case 1: {

            if      (keyStatus[1] == partialPRESS)oled(3, 0, F("2p")); // just to show different positions
            else if (keyStatus[1] == normalPRESS)oled(3, 0, F("2n"));
            else if (keyStatus[1] == heldPRESS)oled(3, 0, F("2h"));
            else if (keyStatus[1] == stuck)oled(3, 0, F("2s"));
            else oled(3, 0, F("  "));
            if (keyStatus[1] == notPRESSED) {
              state2 = 0;
            }
            else state2 = 1;
            break;
          }
        default: state2 = 0;
      }


      switch (state3) {

        case 0: {

            if (keyStatus[2] != notPRESSED) {
              state3 = 1;
            }
            break;
          }
        case 1: {
            if      (keyStatus[2] == partialPRESS)oled(6, 0, F("3p")); // just to show different positions
            else if (keyStatus[2] == normalPRESS)oled(6, 0, F("3n"));
            else if (keyStatus[2] == heldPRESS)oled(6, 0, F("3h"));
            else if (keyStatus[2] == stuck)oled(6, 0, F("3s"));
            else oled(6, 0, F("  "));
            if (keyStatus[2] == notPRESSED) {
              state3 = 0;
            }
            else state3 = 1;
            break;
          }
        default: state3 = 0;
      }
      switch (state4) {

        case 0: {

            if (keyStatus[3] != notPRESSED) {
              state4 = 1;
            }
            break;
          }
        case 1: {
            if      (keyStatus[3] == partialPRESS)oled(0, 2, F("4p")); // just to show different positions
            else if (keyStatus[3] == normalPRESS)oled(0, 2, F("4n"));
            else if (keyStatus[3] == heldPRESS)oled(0, 2, F("4h"));
            else if (keyStatus[3] == stuck)oled(0, 2, F("4s"));
            else oled(0, 2, F("  "));
            if (keyStatus[3] == notPRESSED) {
              state4 = 0;
            }
            else state4 = 1;
            break;
          }
        default: state4 = 0;
      }
      switch (state5) {

        case 0: {

            if (keyStatus[4] != notPRESSED) {
              state5 = 1;
            }
            break;
          }
        case 1: {
            if      (keyStatus[4] == partialPRESS)oled(3, 2, F("5p")); // just to show different positions
            else if (keyStatus[4] == normalPRESS)oled(3, 2, F("5n"));
            else if (keyStatus[4] == heldPRESS)oled(3, 2, F("5h"));
            else if (keyStatus[4] == stuck)oled(3, 2, F("5s"));
            else oled(3, 2, F("  "));
            if (keyStatus[4] == notPRESSED) {
              state5 = 0;
            }
            else state5 = 1;
            break;
          }
        default: state5 = 0;
      }
      switch (state6) {

        case 0: {

            if (keyStatus[5] != notPRESSED) {
              state6 = 1;
            }
            break;
          }
        case 1: {
            if      (keyStatus[5] == partialPRESS)oled(6, 2, F("6p")); // just to show different positions
            else if (keyStatus[5] == normalPRESS)oled(6, 2, F("6n"));
            else if (keyStatus[5] == heldPRESS)oled(6, 2, F("6h"));
            else if (keyStatus[5] == stuck)oled(6, 2, F("6s"));
            else oled(6, 2, F("  "));
            if (keyStatus[5] == notPRESSED) {
              state6 = 0;
            }
            else state6 = 1;
            break;
          }
        default: state6 = 0;
      }
      switch (state7) {

        case 0: {

            if (keyStatus[6] != notPRESSED) {
              state7 = 1;
            }
            break;
          }
        case 1: {
            if      (keyStatus[6] == partialPRESS)oled(0, 4, F("7p")); // just to show different positions
            else if (keyStatus[6] == normalPRESS)oled(0, 4, F("7n"));
            else if (keyStatus[6] == heldPRESS)oled(0, 4, F("7h"));
            else if (keyStatus[6] == stuck)oled(0, 4, F("7s"));
            else oled(0, 4, F("  "));
            if (keyStatus[6] == notPRESSED) {
              state7 = 0;
            }
            else state7 = 1;
            break;
          }
        default: state7 = 0;
      }
      switch (state8) {

        case 0: {

            if (keyStatus[7] != notPRESSED) {
              state8 = 1;
            }
            break;
          }
        case 1: {
            if      (keyStatus[7] == partialPRESS)oled(3, 4, F("8p")); // just to show different positions
            else if (keyStatus[7] == normalPRESS)oled(3, 4, F("8n"));
            else if (keyStatus[7] == heldPRESS)oled(3, 4, F("8h"));
            else if (keyStatus[7] == stuck)oled(3, 4, F("8s"));
            else oled(3, 4, F("  "));
            if (keyStatus[7] == notPRESSED) {
              state8 = 0;
            }
            else state8 = 1;
            break;
          }
        default: state8 = 0;
      }
      switch (state9) {

        case 0: {

            if (keyStatus[8] != notPRESSED) {
              state9 = 1;
            }
            break;
          }
        case 1: {
            if      (keyStatus[8] == partialPRESS)oled(6, 4, F("9p")); // just to show different positions
            else if (keyStatus[8] == normalPRESS)oled(6, 4, F("9n"));
            else if (keyStatus[8] == heldPRESS)oled(6, 4, F("9h"));
            else if (keyStatus[8] == stuck)oled(6, 4, F("9s"));
            else oled(6, 4, F("  "));
            if (keyStatus[8] == notPRESSED) {
              state9 = 0;
            }
            else state9 = 1;
            break;
          }
        default: state9 = 0;
      }
      switch (stateS) {

        case 0: {

            if (keyStatus[9] != notPRESSED) {
              stateS = 1;
            }
            break;
          }
        case 1: {

            if      (keyStatus[9] == partialPRESS)oled(0, 6, F("*p")); // just to show different positions
            else if (keyStatus[9] == normalPRESS)oled(0, 6, F("*n"));
            else if (keyStatus[9] == heldPRESS)oled(0, 6, F("*h"));
            else if (keyStatus[9] == stuck)oled(0, 6, F("*s"));
            else oled(0, 6, F("  "));
            if (keyStatus[9] == notPRESSED) {
              stateS = 0;
            }
            else stateS = 1;
            break;
          }
        default: stateS = 0;
      }
      switch (state0) {

        case 0: {

            if (keyStatus[10] != notPRESSED) {
              state0 = 1;
            }
            break;
          }
        case 1: {
            if      (keyStatus[10] == partialPRESS)oled(3, 6, F("0p")); // just to show different positions
            else if (keyStatus[10] == normalPRESS)oled(3, 6, F("0n"));
            else if (keyStatus[10] == heldPRESS)oled(3, 6, F("0h"));
            else if (keyStatus[10] == stuck)oled(3, 6, F("0s"));
            else oled(3, 6, F("  "));
            if (keyStatus[10] == notPRESSED) {
              state0 = 0;
            }
            else state0 = 1;
            break;
          }
        default: state0 = 0;
      }
      switch (stateH) {

        case 0: {

            if (keyStatus[11] != notPRESSED) {
              stateH = 1;
            }
            break;
          }
        case 1: {
            if      (keyStatus[11] == partialPRESS)oled(6, 6, F("#p")); // just to show different positions
            else if (keyStatus[11] == normalPRESS)oled(6, 6, F("#n"));
            else if (keyStatus[11] == heldPRESS)oled(6, 6, F("#h"));
            else if (keyStatus[11] == stuck)oled(6, 6, F("#s"));
            else oled(6, 6, F("  "));
            if (keyStatus[11] == notPRESSED) {
              stateH = 0;
            }
            else stateH = 1;
            break;
          }
        default: stateH = 0;
      }
    }

  }
}
